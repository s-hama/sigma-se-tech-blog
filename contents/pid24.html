<div class="post-body">
  <h2 id="目的">目的</h2>
  <p>この記事では、損失関数と数値微分について簡単な実装サンプルを記載する。</p>
  <h2 id="概念の説明と実装サンプル">概念の説明と実装サンプル</h2>
  <h3 id="損失関数と微分の関係">損失関数と微分の関係</h3>
  <p>
    前の記事でも触れた交差エントロピー誤差などの損失関数が取る値は、<strong>小さいほど正解に近づいている</strong>が、もちろんそこで終わりではなく<strong>今の結果より正解に近い</strong>パラメータ候補（重み、バイアス）を決めてさらに正解に近づけなければ意味がない。
  </p>
  <p>そこで基準になるのが<strong>重みパラメータの微分結果（勾配値）</strong>である。</p>
  <p>具体的な説明は割愛するが、<strong>一つの重みパラメータの微分結果</strong>と<strong>損失関数の結果</strong>は、密接な関係にある。</p>
  <p>
    <strong>微分結果が負</strong>であれば、正の方向に重みパラメータを変化させることで損失関数の結果も小さくなり、同様に<strong>微分結果が正</strong>であれば、負の方向に重みパラメータを変化させることで損失関数の結果も小さくなる。
  </p>
  <p>この要領で重みパラメータを変化幅を少しずつ減らしながらこの作業を繰り返すことで、<strong>微分結果が \(0\) に収束し、その結果、損失関数の結果も \(0\) に収束する</strong>ことになる。</p>
  <p>但し、この概念を理解する上で注意しなければならないのが <a class="link-secondary"
      href="https://sigma-se.com/detail/18/#:~:text=%E3%81%A8%E5%AE%9F%E8%A3%85%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB-,%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E9%96%A2%E6%95%B0,-%E5%89%8D%E3%81%AE%E8%A8%98%E4%BA%8B">Python
      - AI : 活性化関数の実装サンプルまとめ（ステップ、シグモイド、ReLU、恒等関数、ソフトマックス関数）&gt; ステップ関数</a> のように、<strong>\(x = 0\) 以外の値で微分結果が
      \(0\)（勾配が\(0\)）となるような損失関数</strong>では、そもそも正解に近づけようがないため、微分する意味がない。</p>
  <p>つまり、<strong>損失関数は連続（曲線状の変化をしている）でなければ</strong>、微分する意味がない。</p>
  <p>
    また、この<strong>連続性をもつこと</strong>とは、<strong>損失関数の結果が実数である</strong>ということになるが、<strong>実数と実数の間に隙間はない</strong>ので、いくらでも際限なく損失関数の<strong>極微量な区間の微分結果を探索する</strong>ことができ、ここに微分の性質が利用されている。
  </p>
</div>
