## タイトル
Python - AI : 損失関数と数値微分（勾配）の実装サンプル

## 目的
この記事では、損失関数と数値微分について簡単な実装サンプルを記載する。

## 概念の説明と実装サンプル
### 損失関数と微分の関係
前の記事でも触れた交差エントロピー誤差などの損失関数が取る値は、**小さいほど正解に近づいている**が、もちろんそこで終わりではなく**今の結果より正解に近い**パラメータ候補（重み、バイアス）を決めてさらに正解に近づけなければ意味がない。

そこで基準になるのが**重みパラメータの微分結果（勾配値）**である。

具体的な説明は割愛するが、**一つの重みパラメータの微分結果**と**損失関数の結果**は、密接な関係にある。

**微分結果が負**であれば、正の方向に重みパラメータを変化させることで損失関数の結果も小さくなり、同様に**微分結果が正**であれば、負の方向に重みパラメータを変化させることで損失関数の結果も小さくなる。

この要領で重みパラメータを変化幅を少しずつ減らしながらこの作業を繰り返すことで、**微分結果が \\(0\\) に収束し、その結果、損失関数の結果も \\(0\\) に収束する**ことになる。

但し、この概念を理解する上で注意しなければならないのが [Python - AI : 活性化関数の実装サンプルまとめ（ステップ、シグモイド、ReLU、恒等関数、ソフトマックス関数）> ステップ関数](https://sigma-se.com/detail/18/#:~:text=%E3%81%A8%E5%AE%9F%E8%A3%85%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB-,%E3%82%B9%E3%83%86%E3%83%83%E3%83%97%E9%96%A2%E6%95%B0,-%E5%89%8D%E3%81%AE%E8%A8%98%E4%BA%8B) のように、**\\(x = 0\\) 以外の値で微分結果が \\(0\\)（勾配が\\(0\\)　）となるような損失関数**では、そもそも正解に近づけようがないため、微分する意味がない。

つまり、**損失関数は連続（曲線状の変化をしている）でなければ**、微分する意味がない。

また、この**連続性をもつこと**とは、**損失関数の結果が実数である**ということになるが、**実数と実数の間に隙間はない**ので、いくらでも際限なく損失関数の**極微量な区間の微分結果を探索する**ことができ、ここに微分の性質が利用されている。
